## 2.1 写代码之前: 

### 2.1.1 Go程序开发注意事项:

- go源文件以`.go`为扩展名
- go应用程序的执行是以 `main()`函数为入口
- go语言严格区分大小写
- Go方法由一条条语句构成, 语句后面不需要加`;`表示语句结束,因为`go语言会在每行后面自动加上分号`
- Go编译器是一行一行进行编译的,所以一行就写一条语句就行,`多条语句写在一起回报错`
- go语言`定义了的变量`,或者`导入了的包`没有使用到的话会报错.
- 大括号需要成对出现.

### 2.1.2 Go语言常用的转义字符:  

与其他语言一样:  反斜杠`\`表示转义

```go
\t 制表符
\n 换行符
\\ 将反斜杠转义成"\"字符
\" 将" " " 转义成 " " "字符
\r 将r字母转义成一个回车
```

### 2.1.3 Go语言的注释:  

```go
// 这是行注释
/* 这是块注释 */  
```

> 注释的使用习惯:  
>
> 块注释只是用来描述当前.go文件的作用
>
> 行注释通常是用来注释方法和语句(官方建议)

### 2.1.4 Go代码基本结构:   

```go
package main
/*
块注释写在这里,用来解释整个文件是做什么的:
go 文件结构演示 --- hello world
*/

// 导入外部包的语句
import "fmt"

// go程序入口函数
func main() {
	
	fmt.Println("hello world!")
}
```

### 2.1.5 Go语言中保留字 --- 关键字:  

**关键字**是预先约定好的具有特殊含义的标识符,通常不建议将 `关键字` 和`保留字`作其他用途.

- `关键字`: 

  ```go
      break        default      func         interface    select
      case         defer        go           map          struct
      chan         else         goto         package      switch
      const        fallthrough  if           range        type
      continue     for          import       return       var
  ```

- `保留字`:  

  ```go
      Constants:    true  false  iota  nil
  
          Types:    int  int8  int16  int32  int64  
                    uint  uint8  uint16  uint32  uint64  uintptr
                    float32  float64  complex128  complex64
                    bool  byte  rune  string  error
  
      Functions:   make  len  cap  new  append  copy  close  delete
                   complex  real  imag
                   panic  recover
  ```



-----------------------------



## 2.2 变量,常量:

注意事项: 

1. 无论是变量还是常量,在同一个作用域内名字都是不能重复的
2. 变量有数据类型的区别,同一个变量只能在该类型的取值范围中不断变化

### 2.2.1 变量 :  

1. `标识符`: 表示符表示具有特殊意义的词,比如变量名,常量名,函数名等等.

   go语言标识符规范:  由**`字符`**,**`数字`**,和**`_`** 组成,并且 <font color=red>只能由`字母`或者 `_`开头</font>

3. 声明变量的几种方式：

   - 标准声明:  

     ```go
     var 变量名 数据类型
     ```

   - 声明变量并初始化:  

     <font color=red> 在声明变量并初始化的时候,go语言能够对变量的类型进行推导</font>

     - 初始化单个变量: 

     ```go
     var 变量名 数据类型 = 表达式
     var 变量名 = 表达式  // 类型推导
     ```

     - 多个变量同时初始化: 

     ```go
     var 变量1,变量2 = 表达式1,表达式2
     ```

   - 短变量声明: 使用 `:=`符号进行短变量声明,并初始化

     ```go
     变量名 := 表达式
     ```

     <font color=red><b>注意:</b>    如果不同时初始化变量是不能使用短变量声明的</font>

   - 匿名变量的声明:  使用 `_`表示一个匿名变量,并且`可以不使用`

     ```go
     _ := 表达式
     ```
     
   - 批量声明:  在声明的时候可以选择赋值与不赋值.
   
     ```go
     	// 批量声明 不赋值
     	var (
     		num int
     		age int
     		sex byte
     	)
     
     	// 批量声明 赋值
     	var (
     		nam int = 15
     		age1 int = 169
     		sex2 byte = 'g'
     	)
     ```
   
     <font color=red><b>问题:</b> 为什么byte存字符的时候,不赋值用%c输出会乱码</font>
   
     猜测:  byte的默认值超出了0-255.
   > 变量声明注意:
   > 1. 匿名变量不占用命名空间,`不会分配内存`,不存在匿名变量重复声明的问题
   > 2. 函数外的每个语句都必须以关键字开始,(`var`,`const`,`func`等)
   > 3. `:=`不能使用在函数之外
   > 4. `_`通常是用来占位置的,用来忽略某个值
   
3. 全局变量:   在`方法之外`通过下列语法声明的变量  

   ```go
   // 声明单个全局变量
   var 变量名 = 表达式  
   // 声明多个全局变量
   var (
   	变量名1 = 表达式1
       变量名2 = 表达式2
   )
   ```

   > 全局变量声明之后可以不使用.

4. 相关演示代码:  

   ```go
   package main
   
   import "fmt"
   // 声明一个全局变量, 必须赋值
   var globalVar = "全局变量"
   func main() {
   	varDeclaration()
   }
   var globalVarAfterFuncWasCalled = "在方法被调用之后声明的全局变量"
   // 变量常量的声明
   func varDeclaration(){
   	fmt.Printf("全局变量global var :  %s \n",globalVar)
   	fmt.Printf("能不能输出方法调用之后声明的变量: %s \n",globalVarAfterFuncWasCalled)
   	fmt.Printf("能不能输出方法定义之后声明的变量: %s \n",globalVarAfterFuncWasDecleared)
   	// 标准声明方式,如果不赋值就使用变量所属类型的默认值
   	var i int
   	fmt.Printf("变量 i 的值为 %d ,是否是int类型的默认值 0 : %t \n",i, i == 0)
   
   	// var i int = 10 错误的声明,变量i已经被声明过了
   	// 声明并复制:
   	var j int = 20
   	// 类型推导
   	var c = 20
   	fmt.Printf("变量 j 的值为 %d ,是否是int类型的默认值 0 : %t, 因为已经赋值了 \n",j, j == 0)
   	fmt.Printf("类型推导的c是一个 %T 类型,他的值为 %d  \n",c,c)
   
   	// 短变量声明: 实际上就是通过类型推导直接复制
   	a := "王二麻子"
   	fmt.Printf("a 是一个短变量声明出来的变量, 其类型为 %T , 值为 %s\n",a,a)
   
   	// 匿名变量的声明,匿名变量可以声明了不使用
   	var name,_ = "张三",anonymousVar()
   	fmt.Printf("通过匿名变量忽略了函数返回值,name的值为: %s \n",name)
   
   }
   
   var globalVarAfterFuncWasDecleared = "在方法定义之后声明的全局变量"
   
   func anonymousVar() string{
   	return "匿名变量"
   }
   /**
   输出结果: 
   -------------------------------------------------------------
   全局变量global var :  全局变量
   能不能输出方法调用之后声明的变量: 在方法被调用之后声明的全局变量
   能不能输出方法定义之后声明的变量: 在方法定义之后声明的全局变量
   变量 i 的值为 0 ,是否是int类型的默认值 0 : true
   变量 j 的值为 20 ,是否是int类型的默认值 0 : false, 因为已经赋值了
   类型推导的c是一个 int 类型,他的值为 20
   a 是一个短变量声明出来的变量, 其类型为 string , 值为 王二麻子
   通过匿名变量忽略了函数返回值,name的值为: 张三
   */
   ```

   **`fmt`包中`printf`函数的占位符**

   ```go
   /**
   
   printf格式化打印占位符：
               %v,原样输出
               %T，打印类型
               %t,bool类型
               %s，字符串
               %f，浮点
               %d，10进制的整数
               %b，2进制的整数
               %o，8进制
               %x，%X，16进制
                   %x：0-9，a-f
                   %X：0-9，A-F
               %c，打印字符
               %p，打印地址
    */	
   ```


### 2.2.2 常量:  

**Go常量**`const`是属于编译时期的常量，即在编译时期就可以完全确定取值的常量。<font color=red><b>只支持`数字`，`字符串`和`布尔值`，及`上述类型的表达式`</b> </font>。而切片，数组，正则表达式等等需要在运行时分配空间和执行若干运算才能赋值的变量则不能用作常量。

1. 常量声明:

   - 声明语法:  

     ```go
     const 变量名 = 表达式
     // 表达式说明： 
     // go语言中常量声明的时候的表达式，只支持数值，字符串，布尔值，以及以上类型组成的表达式
     // 常量声明时的表达式,表达式参与成员都必须要是常量 
     const (
     	firstTimeCall = getAndAddConstC() + 1 // 不支持函数作为常量表达式使用.
     )
     ```

   - 单个常量: 

     ```go
     	// 声明单个常量
     	const pi = 3.1415926
     ```

     

   - 多个常量: 

     ```go
     	// 如果某个常量在声明时赋值了,该常量之后没有声明的常量都是那一个表达式的结果.
     	const (
     		minutes = 12
     		hours
     		day
     		month = 01
     		year
     	)
     ```

     - <font color=red>注意:</font>

       多个常量声明的时候,如果某个常量(`比如:day`)没有进行赋值,那么该常量的值就是离他最近的赋了值的`常量表达式的结果`(`比如: day的值为12,year的值为1`)

       ```go
       	// 如果某个常量在声明时赋值了,该常量之后没有声明的常量都是那一个表达式的结果.
       	// 下面这个例子,由于c,e;d,f都没有赋值,所以分别对应使用iota+1,iota+2表达式,但是在常量声明中每新增一行声明就会让iota+1
       	const (
       		a, b = iota + 1, iota + 2 //a = 1, b = 2
       		c, d                      //2,3
       		e, f                      //3,4
       		g,h = 10, 20
       	)
       	fmt.Printf("a = %d ,b = %d\n",a,b)
       	fmt.Printf("c = %d ,d = %d\n",c,d)
       	fmt.Printf("e = %d ,f = %d\n",e,f)
       	fmt.Printf("g = %d ,h = %d\n",g,h)
       ```

       

2. **iota**: go语言中的常量计数器,只能在常量表达式中使用

   **iota**在`const`关键字出现时将被充值为0.`const`中`每新增一行常量声明`将会让`iota`+1.使用`iota`能够简化定义,在定义枚举的时候很有用.

   <font color=red>注意:<b>是每新增一行,会让iota+1</b></font>,而不是每增加一个常量就会让iota自增1.

   使用示例:  

   - 通常使用:  

     ```go
     	// iota使用示例
     	const (
     		n1 = iota // 0
     		n2		  // 1
     		n3        // 2
     		n4        // 3
     		n5        // 4
     	)
     ```

   - _ 跳过某些值:  

     ```go
     	// 用 _ 跳过不需要的值
     	const (
     		a1 = iota //0
     		a2        //1
     		_
     		a4        //3
     	)
     ```

   - 常量声明,iota中间插队

     ```go
     	// iota 中间插队,使iota增加
     	const (
     		c1 = iota //0
     		c2 = 100  //100
     		c3 = iota //2
     		c4        //3
     	)
     	const c5 = iota //0
     ```

   - 定义某个数量级

     ```go
     // 使用iota来定义某个数量级
     const (
        _  = iota                  // 0
        KB = 1 << (10 * iota)     // 1024
        MB = 1 << (10 * iota)
        GB = 1 << (10 * iota)
        TB = 1 << (10 * iota)
        PB = 1 << (10 * iota)
     )
     ```

   - 多个iota定义在同一行:  

     ```go
     // 多个iota定义在一行
     const (
        a, b = iota + 1, iota + 2 //a = 1, b = 2
        c, d                      //2,3
        e, f                      //3,4
     )
     ```

     <font color=red>注意:<b>是每新增一行,会让iota+1</b></font>,而不是每增加一个常量就会让iota自增1.

## 2.3 Go的数据类型

![image-20210717211249925](E:\doc\MyGoSummary\docs\chapter01_GoSyntax\02_go基础语法.assets\image-20210717211249925.png)

> 1. go语言是没有字符类型的,通过byte存储单个字符的ASC码值表示单个字符
> 2. go语言采用的是UTF-8的编码方式,汉字为3个字节,所以1byte无法存储一个汉字
> 3. bool类型只能使用`true`,`false`两个值,`不能像c语言那样非0即真`
> 4. 结构体类似于`c语言中的结构体`

> 默认初始值:  
>
> - 整型,浮点数                                        ===>  0
> - 字符串                                                 ===>   ""(空串)
> - 布尔类型                                             ===>        false
> - 切片,函数,指针等引用类型                ===>        nil(空指针)
>
> 可以使用`printf`函数,通过`%T`输出变量的数据类型

### 2.3.1 基本类型:

#### 1.整数类型: 

go语言的整数类型分为`有符号`,`无符号`,`特殊整数类型`

- 无符号整数:

  |   类型   | 描述                                        | 占有字节数 |
  | :------: | :------------------------------------------ | ---------- |
  | `uint8`  | 无符号 8位整型 (0 到 255)                   | 1字节      |
  | `uint16` | 无符号 16位整型 (0 到 65535)                | 2字节      |
  | `uint32` | 无符号 32位整型 (0 到 4294967295)           | 4字节      |
  | `uint64` | 无符号 64位整型 (0 到 18446744073709551615) | 8字节      |

- 有符号整数:   

  |  类型   | 描述                                                         | 占有字节数 |
  | :-----: | :----------------------------------------------------------- | ---------- |
  | `int8`  | 有符号 8位整型 (-128 到 127)                                 | 1字节      |
  | `int16` | 有符号 16位整型 (-32768 到 32767)                            | 2字节      |
  | `int32` | 有符号 32位整型 (-2147483648 到 2147483647)                  | 4字节      |
  | `int64` | 有符号 64位整型 (-9223372036854775808 到 9223372036854775807) | 8字节      |

- 特殊整数类型

  |   类型    | 描述                                                   | 有无符号 | 占有字节数 |
  | :-------: | :----------------------------------------------------- | -------- | ---------- |
  |  `uint`   | 32位操作系统上就是`uint32`，64位操作系统上就是`uint64` | 无       |            |
  |   `int`   | 32位操作系统上就是`int32`，64位操作系统上就是`int64`   | 有       |            |
  | `uintptr` | 无符号整型，用于存放一个指针                           |          |            |
  |  `rune`   | 与`int32`等价,表示一个Unicode码                        | 有       | 4          |
  |  `byte`   | 与`uint8`等价                                          | 无       | 1字节      |

> 1. `uint8`对应`byte类型`
> 2. `int`和`uint`在使用的时候应该考虑到不同平台上可能产生的差异.
> 3. 在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用`int`和 `uint`。

**整数类型的使用示例: **

```go
//测试int类型的默认值
/**
测试结果:
有符号: int = 0,int8 = 0,int16 = 0,int32 = 0
无符号: uInt = 0,uInt8 = 0,uInt16 = 0,uInt32 = 0
rune default value = 0
byte default value = 0
*/
func testIntDefaultValue() {
   var (
      varInt   int
      varInt8  int8
      varInt16 int16
      varInt32 int32
   )
   fmt.Printf("有符号: int = %d,int8 = %d,int16 = %d,int32 = %d\n", varInt, varInt8, varInt16, varInt32)
   var (
      varuInt   uint
      varuInt8  uint8
      varuInt16 uint16
      varuInt32 uint32
   )
   fmt.Printf("无符号: uInt = %d,uInt8 = %d,uInt16 = %d,uInt32 = %d\n", varuInt, varuInt8, varuInt16, varuInt32)

   var varRune rune
   fmt.Printf("rune default value = %d\n", varRune)

   var varByte byte
   fmt.Printf("byte default value = %d\n", varByte)
}
```

**整型使用细节**

1. 默认情况下,整数赋值给变量默认是 `int`类型
2. `根据保小不保大的原则`,在定义变量的时候,保证逻辑不出现问题的情况下,尽量选择占用空间小的数据类型,比如: [年龄]

```go
// IntUseDetail 整数的使用细节:
/**
结果:
--------------------------------
n1的数据类型为 int, n1占用的字节数为: 8(默认是int ,int在64为系统中为8字节)
*/
func IntUseDetail() {
	// 查看变量的数据类型和占有的字节大小
	// 整数复制给变量默认是int类型
	n1 := 1999
	fmt.Printf("n1的数据类型为 %T, n1占用的字节数为: %d", n1, unsafe.Sizeof(n1))

	// golang有一个保小不保大的原则,就是说保证程序不出问题的情况下,尽量使用占用字节数少的数据类型
	// 举个例子: 年龄,一般就是0-150岁,这是最小的数据类型使用byte(0-255)就可以了
	var age byte = 200
	fmt.Printf("age : %d ", age)
}
```

####　2. 浮点数类型:  

