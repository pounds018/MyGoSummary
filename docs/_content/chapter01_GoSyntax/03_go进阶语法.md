## 3.1 文件操作:

### 1. 概述

文件在程序中是以流的形式来操作的:

![image-20210730224320497](03_go进阶语法.assets/image-20210730224320497.png)

`os包`提供了操作系统函数的不依赖平台的接口。设计为Unix风格的，虽然错误处理是go风格的；失败的调用会返回错误值而非错误码。通常错误值里包含更多信息。例如，如果某个使用一个文件名的调用（如Open、Stat）失败了，打印错误时会包含该文件名，错误类型将为`*PathError`，其内部可以解包获得更多信息。

`os包`的接口规定为在所有操作系统中都是一致的。非公用的属性可以从操作系统特定的[`syscall](http://godoc.org/syscall)包获取。

`os包`中通过`File结构体`来描述文件相关信息

```go
type file struct {
	pfd        poll.FD
	name       string
	dirinfo    *dirInfo // nil unless directory being read
	appendMode bool     // whether file is opened for appending
}
```

常用的文件相关方法:  

![常用方法](03_go进阶语法.assets/image-20210730225337611.png)
### 2. 路径问题:

**相对路径:** 就是当前项目的根目录,比如当前项目 `test`全路径如图

![image-20210731002738525](03_go进阶语法.assets/image-20210731002738525.png)

![image-20210731003218638](03_go进阶语法.assets/image-20210731003218638.png)

说明: 通过`os.Getwd()`获取到了项目的根据路径,上面两张图片,都希望在当前文件夹(`./`表示当前文件夹)通过 `os.Create()`创建一个`test.md`文件,结果如图,说明 go项目的相对路径,是从项目的跟路径开始的.

如果要使用相对路径(`相对于当前go文件`)去加载文件,正确的做法是: 

```go
func create() {
	_, file, _, _ := runtime.Caller(0)
	fmt.Println("file = ",file)

	curFileDir := path.Dir(file)
	fmt.Println("path.Dir(file) = ",curFileDir)

	targetPath := path.Join(curFileDir, PATH)
	fmt.Println("join = ",targetPath)

	create, err := os.Create(targetPath)
	if err != nil {
		fmt.Println("create file err = ",err)
	}
}
```

1. 通过`runtime.Caller(0)拿到当前执行的栈帧信息,参数为向上回溯的栈帧数`获取当前正在运行的源文件的全路径
2. 通过`path.Join()`将 `当前运行源文件的全路径` 和 `相对于当前源文件的目标路径()`,拼接起来处理成 需要的全路径
3. 然后通过这个路径去做一些文件操作

如果通过项目根路径去操作,就直接把需要的路径补全就行.

```go
	// 打开文件
	file, err := os.Open("./chapter03_goAdvance/01_File/test/test.txt")
	if err != nil {
		fmt.Println("open file err = ",err)
	}
	// 看看file是什么类型的
	fmt.Printf("file = %v\n",file)

	if err = file.Close(); err != nil {
		fmt.Println("close file err = ",err)
	}
```



### 3. 文件的基本操作:  

#### 1. 开关文件:

**打开:**

```go
/* 
name string: 文件名
*File: 返回指向该文件的指针
error: 打开文件错误,类型为 *PathError
*/
func Open(name string) (*File, error)
```

**关闭:**

```go
/*
f *File: 要关闭的文件指针
error: 关闭时发生的错误
*/
func (f *File) Close() error 
```

```go
// 开关文件
func openClose() {
	// 打开文件
	file, err := os.Open("./chapter03_goAdvance/01_File/test/test.txt")
	if err != nil {
		fmt.Println("open file err = ",err)
	}
	// 看看file是什么类型的
	fmt.Printf("file = %v\n",file)

	if err = file.Close(); err != nil {
		fmt.Println("close file err = ",err)
	}
}
```

#### 2. 读写文件

**读取文件:**

```go
/*
以只读形式打开文件
name: 文件路径
*/
func Open(name string) (*File, error)
```

```go
// 将文件读取到缓冲区中,通过缓冲区读取文件
func operater() {
   open, err := os.Open("./chapter03_goAdvance/01_File/test/test.txt")
   if err != nil {
      return
   }
   defer func(open *os.File) {
      err := open.Close()
      if err != nil {
         fmt.Println("close file fialed = ", err)
      }
   }(open)

   // 创建一个带缓冲区的reader
   reader := bufio.NewReader(open)
   for {
      // 注意这里会将 换行符一起读取'\n'
      readString, err := reader.ReadString('\n')
      fmt.Print(readString)
      // 读取到文件末尾,退出循环
      if err == io.EOF {
         break
      }
   }

   fmt.Println("操作结束")
}
```

------------------

```go
/*
自选打开文件的模式
name: 文件路径
flag: 打开文件的模式(用 | 组合)
perm: 文件权限控制(主要是linux使用,win没有用)
*/
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
```

`flag`:

```go
const (
    O_RDONLY int = syscall.O_RDONLY // 只读模式打开文件
    O_WRONLY int = syscall.O_WRONLY // 只写模式打开文件
    O_RDWR   int = syscall.O_RDWR   // 读写模式打开文件
    O_APPEND int = syscall.O_APPEND // 写操作时将数据附加到文件尾部
    O_CREATE int = syscall.O_CREAT  // 如果不存在将创建一个新文件
    O_EXCL   int = syscall.O_EXCL   // 和O_CREATE配合使用，文件必须不存在
    O_SYNC   int = syscall.O_SYNC   // 打开文件用于同步I/O
    O_TRUNC  int = syscall.O_TRUNC  // 如果可能，打开时清空文件
)
```

`FileMode`: 

```go
const (
    // 单字符是被String方法用于格式化的属性缩写。
    ModeDir        FileMode = 1 << (32 - 1 - iota) // d: 目录
    ModeAppend                                     // a: 只能写入，且只能写入到末尾
    ModeExclusive                                  // l: 用于执行
    ModeTemporary                                  // T: 临时文件（非备份文件）
    ModeSymlink                                    // L: 符号链接（不是快捷方式文件）
    ModeDevice                                     // D: 设备
    ModeNamedPipe                                  // p: 命名管道（FIFO）
    ModeSocket                                     // S: Unix域socket
    ModeSetuid                                     // u: 表示文件具有其创建者用户id权限
    ModeSetgid                                     // g: 表示文件具有其创建者组id的权限
    ModeCharDevice                                 // c: 字符设备，需已设置ModeDevice
    ModeSticky                                     // t: 只有root/创建者能删除/移动文件
    // 覆盖所有类型位（用于通过&获取类型位），对普通文件，所有这些位都不应被设置
    ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice
    ModePerm FileMode = 0777 // 覆盖所有Unix权限位（用于通过&获取类型位）
)
```

```go
// 创建并写入内容
func write(){
   str := "str et test\n"
   filePath := "./chapter03_goAdvance/01_File/file"

   // 这种方式不能直接创建的,因为没有上级目录
   //file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, 0666)
   err := os.MkdirAll(filePath,0666)
   if err != nil {
      fmt.Println("create dir failed : ",err)
   }
   file, err := os.OpenFile(filePath+"/file.md", os.O_WRONLY|os.O_CREATE, 0666)
   if err != nil {
      fmt.Println("create dir failed : ",err)
   }
   defer file.Close()

   writer := bufio.NewWriter(file)
   for i := 0; i < 5; i++ {
      _, err2 := writer.WriteString(str)
      if err2 != nil {
         fmt.Println("write file err = ",err)
      }
   }

   err = writer.Flush()
   if err != nil {
      fmt.Println("flush file err =",err)
   }
   fmt.Println("write success")
}
```

**写入文件:**

1. 清空源文件,然后写入文件. 即 以`os.TRUNC`打开文件
2. 在源文件后面追加内容, 即以 `os.APPEND`打开文件
3. 读取文件并追加内容, 即以 `os.RDWR | os.APPEND`打开文件

**判断文件是否存在:**

通过`os.Stat()`函数的返回值来判断文件是否存在

1. 返回的err = nil,表示文件存在
2. 返回的错误不为nil,则用`os.isNotExist(err)`判断,为`ture`说明文件不存在
3. 其他类型的err则 无法确定文件是否存在

![image-20210731151038716](03_go进阶语法.assets/image-20210731151038716.png)

#### 3. 复制文件

**拷贝文件:**

![image-20210731151422181](03_go进阶语法.assets/image-20210731151422181.png)

#### 4. 命令行传参:

1. 获取参数的方式1

在启动go程序的时候可以通过命令行来传参数,所有的参数都存放在 `os.Args`这个切片里面

![image-20210731153222156](03_go进阶语法.assets/image-20210731153222156.png)

2. 获取参数的方式2

   `flag包`实现了命令行参数的解析

   ```go
   func main() {
   	// 定义几个变量用来绑定参数值
   	var user,pwd,host string
   	var port int
   
   	/*
   	func StringVar(p *string, name string, value string, usage string)
   	参数解释:
   	p : 用来接受命令行中指定参数(name)的值,即 参数容器
   	name: 表示匹配命令行中的参数名字
   	value: 是命令行参数的默认值,即 不传就是用这个值
   	usage: 就是描述name参数的用途
   	*/
   	flag.StringVar(&user,"u","root","用户名,默认为default")
   	flag.StringVar(&pwd,"p","root","用户密码,默认为root")
   	flag.StringVar(&host,"h","127.0.0.1","ip,默认为127.0.0.1")
   	flag.IntVar(&port,"P",0,"端口号,默认为0")
   
   	// 这一步必须要有,就是从os.Args中读取出参数存入,否则上面的参数无法使用
   	flag.Parse()
   
   	// 传参的时候必须要用空格和参数标志分开 , 即-u test -p test -h 192.168.1.1 -P 33066
   	fmt.Printf("user = %v, pwd= %v,host = %v,port = %v\n",user,pwd,host,port)
   }
   ```

#### 5. 使用json存储文件:

`json`总是以 `key:value`的形式存储数据,易于机器解析和生成,并有效的提升网络传输效率,通常程序在网络传输的时候,会将数据对象序列化成json字符串,然后在接受方对json字符串进行解析,反序列化成原来的数据对象.

![image-20210731155649872](03_go进阶语法.assets/image-20210731155649872.png)

**序列化:**

```go
/*
v: 要序列化的对象,空接口可以传任意的类型
[]byte: 序列化完成之后返回的是一个byte数组
error: 可能的错误
*/
func Marshal(v interface{}) ([]byte, error) 
```

```go
// Animal 结构体的序列化
type Animal struct {
   Name string
   Age int
   Hobby string
}

func serializeTest(){
   // 序列化map
   mapA := make(map[string]interface{})
   mapA["name"] = "王二麻子"
   mapA["age"] = 30
   mapA["address"] = "花果山"

   jsonString := srializeFunc(mapA)
   fmt.Printf("mapA 转换成json之后的样子是: %v\n",jsonString)

   // 序列化struct,go官方说明序列化struct的时候只会序列化名字大写的属性
   a := &Animal{
      "张珊",
      255,
      "吃",
   }
   jsonString = srializeFunc(a)
   fmt.Printf("struct 转换成json之后的样子是: %v\n",jsonString)
   s := unserializeFunc(jsonString)
   fmt.Printf("struct 反序列化之后的样子是: %T,%s\n",s,s)

}

// 序列化函数
func srializeFunc(object interface{}) string {
	marshal, err := json.Marshal(object)
	if err != nil{
		return "serialize object failed"
	}
	return string(marshal)
}
```

<font color=red>注意:</font>

1. 由于go在转换的时候是需要将`struct对象`放到`json包`里面去使用,<font color=red>所以必须大写,小写字段在序列化的时候会被忽略</font>

2. 在序列化的时候,可以给字段设置是否序列化,序列化的名字,当序列化值为空的时候忽略该字段,<font color=red>但是使用了omitempty之后,各个类型的默认值也会被认为是空值,可以将希望默认值不被忽略的属性写成指针</font>

   ```go
   // User 序列化tag的使用
   type User struct {
   	Age       int    `json:"age,omitempty"` // 指定序列化key,如果值为null就忽略
   	FirstName string `json:"first_name,omitempty"`
   	Address   string `json:"address,omitempty"`
   	Account   string `json:"account,omitempty"`
   	Pwd       string `json:"-"` // 直接省略
   }
   ```

**反序列化:**

```go
/*
data: 需要反序列化的字节数组
v: 接受反序列化的对象,必须与序列化的对象相同
error: 
*/
func Unmarshal(data []byte, v interface{}) error 
```

```go
// Animal 结构体的序列化
type Animal struct {
   Name string
   Age int
   Hobby string
}

func serializeTest(){

   // 序列化struct,go官方说明序列化struct的时候只会序列化名字大写的属性
   a := &Animal{
      "张珊",
      255,
      "吃",
   }
   jsonString = srializeFunc(a)
   fmt.Printf("struct 转换成json之后的样子是: %v\n",jsonString)
   s := unserializeFunc(jsonString)
   fmt.Printf("struct 反序列化之后的样子是: %T,%s\n",s,s)

}
func unserializeFunc(jsonString string) Animal {
	var animal Animal
	err2 := json.Unmarshal([]byte(jsonString), &animal)
	if nil != err2 {
		return Animal{}
	}
	return animal
}
```

错误的示例:

```go
// 反序列化,传入的是Animal类型的字符串,但是用了字符串指针来接收反序列化的结果
func unserializeFunc(jsonString string) string {
	bytes := make([]byte, len(jsonString))
	err := json.Unmarshal(bytes, &jsonString)
	if nil != err {
		return "unserialize failed"
	}
	return string(bytes)
}
```

## 3.2 单元测试: 

go语言自带一个轻量级的测试框架testing和自带的go test命令来实现单元测试和性能测试,testing框架和其他语言的测试框架类似,可以基于这个框架写针对响应函数的测试用例,也可以基于该框架写响应的压力测试用例.

go语言测试依赖 go test命令.编写测试代码和编写普通go代码差不多. 

go test命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以`_test.go`为后缀名的源代码文件都是`go test`测试的一部分，不会被`go build`编译到最终的可执行文件中。

在`*_test.go`文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。

|   类型   |         格式          |              作用              |
| :------: | :-------------------: | :----------------------------: |
| 测试函数 |   函数名前缀为Test    | 测试程序的一些逻辑行为是否正确 |
| 基准函数 | 函数名前缀为Benchmark |         测试函数的性能         |
| 示例函数 |  函数名前缀为Example  |       为文档提供示例文档       |

`go test`命令会遍历所有的`*_test.go`文件中符合上述命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。

单测目的:

1. 确保每个函数可运行且结果正确
2. 确保代码的性能
3. 单元测试可以及时发现程序设计或实现的逻辑问题.

### 1. 测试函数:

每个测试函数必须导入`testing`包，测试函数的基本格式（签名）如下：

```go
func TestName(t *testing.T){
    // ...
}
```

测试函数的名字必须以`Test`开头，可选的后缀名必须以大写字母开头，举几个例子：

```go
func TestAdd(t *testing.T){ ... }
func TestSum(t *testing.T){ ... }
func TestLog(t *testing.T){ ... }
```

其中参数`t`用于报告测试失败和附加的日志信息。 `testing.T`的拥有的方法如下：

```go
func (c *T) Error(args ...interface{})
func (c *T) Errorf(format string, args ...interface{})
func (c *T) Fail()
func (c *T) FailNow()
func (c *T) Failed() bool
func (c *T) Fatal(args ...interface{})
func (c *T) Fatalf(format string, args ...interface{})
func (c *T) Log(args ...interface{})
func (c *T) Logf(format string, args ...interface{})
func (c *T) Name() string
func (t *T) Parallel()
func (t *T) Run(name string, f func(t *T)) bool
func (c *T) Skip(args ...interface{})
func (c *T) SkipNow()
func (c *T) Skipf(format string, args ...interface{})
func (c *T) Skipped() bool
```

关于 `go test` 命令: 



**使用示例:** 在被测试go文件的同包下创建一个同名带后缀`_test`的go文件,然后在里面写测试方法

```go
package testcase

func Add(num int) (res int){
	for i := 0; i < num; i++ {
		res += i
	}
	return res
}

// 测试方法
package testcase

import "testing"

func TestCal(t *testing.T) {
	add := Add(10)
	if add == 45 {
		t.Logf("测试函数: Add(10) 成功,结果 %d 符合预期",add)
	}else {
		t.Errorf("测试结果错误: Add(10) 正确结果为45,实际结果为 %d",add)
	}
}
```

**注意事项:**

1. 单元测试源代码go文件,一定是以`_test`结尾的
2. 测试用例必须以`Test`开头,通常来说就是: `Test + 被测方法名字`
3. 测试函数的参数必须是 `*testing.T`类型
4. 当出现错误的时候,可以使用 `t.FataIf`来格式化输出错误信息,并退出程序
5. 如果要看执行过程信息: `t.Logf`来记录信息
6. 测试用例函数不需要放在main函数里面

### 2. 测试组:

除了测试一个用例之外,还可以测试一组用例

```go
func TestSplit(t *testing.T) { // 测试函数名必须以Test开头，必须接收一个*testing.T类型参数
   // 定义一个测试用例类型
   type test struct {
      input string// 测试内容
      sep   string// 分隔符
      want  []string// 期望的结果
   }
   tests := []test{
      {input: "a:b:c", sep: ":", want: []string{"a", "b", "c"}},
      {input: "a:b:c", sep: ",", want: []string{"a:b:c"}},
      {input: "abcd", sep: "bc", want: []string{"a", "d"}},
      {input: "沙河有沙又有河", sep: "沙", want: []string{"河有", "又有河"}},
   }
   for _,test := range tests {
      got := Split(test.input, ":")         // 程序输出的结果
      if !reflect.DeepEqual(got,test.want) { // 因为slice不能比较直接，借助反射包中的方法比较
         t.Errorf("excepted:%#v, got:%#v", test.want, got) // 测试失败输出错误提示
      }
   }
}
```

### 3. 覆盖率测试

测试覆盖率是你的代码被测试套件覆盖的百分比。通常我们使用的都是语句的覆盖率，也就是在测试中至少被运行一次的代码占总代码的比例。

```go
split $ go test -cover
PASS
coverage: 100.0% of statements
ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.005s
```

### 3. 基准测试:  

基准测试就是在一定的工作负载之下检测程序性能的一种方法

```go
// 性能测试命名方式
func BenchmarkName(b *testing.B){
    // ...
}
```

基准测试以`Benchmark`为前缀，需要一个`*testing.B`类型的参数b，基准测试必须要执行`b.N`次，这样的测试才有对照性，`b.N`的值是系统根据实际情况去调整的，从而保证测试的稳定性。 `testing.B`拥有的方法如下：

```go
func (c *B) Error(args ...interface{})
func (c *B) Errorf(format string, args ...interface{})
func (c *B) Fail()
func (c *B) FailNow()
func (c *B) Failed() bool
func (c *B) Fatal(args ...interface{})
func (c *B) Fatalf(format string, args ...interface{})
func (c *B) Log(args ...interface{})
func (c *B) Logf(format string, args ...interface{})
func (c *B) Name() string
func (b *B) ReportAllocs()
func (b *B) ResetTimer()
func (b *B) Run(name string, f func(b *B)) bool
func (b *B) RunParallel(body func(*PB))
func (b *B) SetBytes(n int64)
func (b *B) SetParallelism(p int)
func (c *B) Skip(args ...interface{})
func (c *B) SkipNow()
func (c *B) Skipf(format string, args ...interface{})
func (c *B) Skipped() bool
func (b *B) StartTimer()
func (b *B) StopTimer()
```

**示例:**

```go
func BenchmarkSplit(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Split("沙河有沙又有河", "沙")
	}
}
```

基准测试并不会默认执行，需要增加`-bench`参数，所以我们通过执行`go test -bench=Split`命令执行基准测试，输出结果如下：

```bash
split $ go test -bench=Split
goos: darwin
goarch: amd64
pkg: github.com/Q1mi/studygo/code_demo/test_demo/split
BenchmarkSplit-8        10000000               203 ns/op
PASS
ok      github.com/Q1mi/studygo/code_demo/test_demo/split       2.255s
```

其中`BenchmarkSplit-8`表示对Split函数进行基准测试，数字`8`表示`GOMAXPROCS`的值，这个对于并发基准测试很重要。`10000000`和`203ns/op`表示每次调用`Split`函数耗时`203ns`，这个结果是`10000000`次调用的平均值。

我们还可以为基准测试添加`-benchmem`参数，来获得内存分配的统计数据。

```bash
split $ go test -bench=Split -benchmem
goos: darwin
goarch: amd64
pkg: github.com/Q1mi/studygo/code_demo/test_demo/split
BenchmarkSplit-8        10000000               215 ns/op             112 B/op          3 allocs/op
PASS
ok      github.com/Q1mi/studygo/code_demo/test_demo/split       2.394s
```

其中，`112 B/op`表示每次操作内存分配了112字节，`3 allocs/op`则表示每次操作进行了3次内存分配。 我们将我们的`Split`函数优化如下：

```go
func Split(s, sep string) (result []string) {
	result = make([]string, 0, strings.Count(s, sep)+1)
	i := strings.Index(s, sep)
	for i > -1 {
		result = append(result, s[:i])
		s = s[i+len(sep):] // 这里使用len(sep)获取sep的长度
		i = strings.Index(s, sep)
	}
	result = append(result, s)
	return
}
```

这一次我们提前使用make函数将result初始化为一个容量足够大的切片，而不再像之前一样通过调用append函数来追加。我们来看一下这个改进会带来多大的性能提升：

```bash
split $ go test -bench=Split -benchmem
goos: darwin
goarch: amd64
pkg: github.com/Q1mi/studygo/code_demo/test_demo/split
BenchmarkSplit-8        10000000               127 ns/op              48 B/op          1 allocs/op
PASS
ok      github.com/Q1mi/studygo/code_demo/test_demo/split       1.423s
```

这个使用make函数提前分配内存的改动，减少了2/3的内存分配次数，并且减少了一半的内存分配。

上面的基准测试只能得到给定操作的绝对耗时，但是在很多性能问题是发生在两个不同操作之间的相对耗时，比如同一个函数处理1000个元素的耗时与处理1万甚至100万个元素的耗时的差别是多少？再或者对于同一个任务究竟使用哪种算法性能最佳？我们通常需要对两个不同算法的实现使用相同的输入来进行基准比较测试。

### 4. 性能比较:

性能比较函数通常是一个带有参数的函数，被多个不同的Benchmark函数传入不同的值来调用。举个例子如下：

```go
func benchmark(b *testing.B, size int){/* ... */}
func Benchmark10(b *testing.B){ benchmark(b, 10) }
func Benchmark100(b *testing.B){ benchmark(b, 100) }
func Benchmark1000(b *testing.B){ benchmark(b, 1000) }
```

例如我们编写了一个计算斐波那契数列的函数如下：

```go
// fib.go

// Fib 是一个计算第n个斐波那契数的函数
func Fib(n int) int {
	if n < 2 {
		return n
	}
	return Fib(n-1) + Fib(n-2)
}
```

我们编写的性能比较函数如下：

```go
// fib_test.go

func benchmarkFib(b *testing.B, n int) {
	for i := 0; i < b.N; i++ {
		Fib(n)
	}
}

func BenchmarkFib1(b *testing.B)  { benchmarkFib(b, 1) }
func BenchmarkFib2(b *testing.B)  { benchmarkFib(b, 2) }
func BenchmarkFib3(b *testing.B)  { benchmarkFib(b, 3) }
func BenchmarkFib10(b *testing.B) { benchmarkFib(b, 10) }
func BenchmarkFib20(b *testing.B) { benchmarkFib(b, 20) }
func BenchmarkFib40(b *testing.B) { benchmarkFib(b, 40) }
```

运行基准测试：

```bash
split $ go test -bench=.
goos: darwin
goarch: amd64
pkg: github.com/Q1mi/studygo/code_demo/test_demo/fib
BenchmarkFib1-8         1000000000               2.03 ns/op
BenchmarkFib2-8         300000000                5.39 ns/op
BenchmarkFib3-8         200000000                9.71 ns/op
BenchmarkFib10-8         5000000               325 ns/op
BenchmarkFib20-8           30000             42460 ns/op
BenchmarkFib40-8               2         638524980 ns/op
PASS
ok      github.com/Q1mi/studygo/code_demo/test_demo/fib 12.944s
```

这里需要注意的是，默认情况下，每个基准测试至少运行1秒。如果在Benchmark函数返回时没有到1秒，则b.N的值会按1,2,5,10,20,50，…增加，并且函数再次运行。

最终的BenchmarkFib40只运行了两次，每次运行的平均值只有不到一秒。像这种情况下我们应该可以使用`-benchtime`标志增加最小基准时间，以产生更准确的结果。例如：

```bash
split $ go test -bench=Fib40 -benchtime=20s
goos: darwin
goarch: amd64
pkg: github.com/Q1mi/studygo/code_demo/test_demo/fib
BenchmarkFib40-8              50         663205114 ns/op
PASS
ok      github.com/Q1mi/studygo/code_demo/test_demo/fib 33.849s
```

这一次`BenchmarkFib40`函数运行了50次，结果就会更准确一些了。

使用性能比较函数做测试的时候一个容易犯的错误就是把`b.N`作为输入的大小，例如以下两个例子都是错误的示范：

```go
// 错误示范1
func BenchmarkFibWrong(b *testing.B) {
	for n := 0; n < b.N; n++ {
		Fib(n)
	}
}

// 错误示范2
func BenchmarkFibWrong2(b *testing.B) {
	Fib(b.N)
}
```

### 5. 重置时间

`b.ResetTimer`之前的处理不会放到执行时间里，也不会输出到报告中，所以可以在之前做一些不计划作为测试报告的操作。例如：

```go
func BenchmarkSplit(b *testing.B) {
	time.Sleep(5 * time.Second) // 假设需要做一些耗时的无关操作
	b.ResetTimer()              // 重置计时器
	for i := 0; i < b.N; i++ {
		Split("沙河有沙又有河", "沙")
	}
}
```

### 6. 并行测试

`func (b *B) RunParallel(body func(*PB))`会以并行的方式执行给定的基准测试。

`RunParallel`会创建出多个`goroutine`，并将`b.N`分配给这些`goroutine`执行， 其中`goroutine`数量的默认值为`GOMAXPROCS`。用户如果想要增加非CPU受限（non-CPU-bound）基准测试的并行性， 那么可以在`RunParallel`之前调用`SetParallelism` 。`RunParallel`通常会与`-cpu`标志一同使用。

```go
func BenchmarkSplitParallel(b *testing.B) {
	// b.SetParallelism(1) // 设置使用的CPU数
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			Split("沙河有沙又有河", "沙")
		}
	})
}
```

执行一下基准测试：

```bash
split $ go test -bench=.
goos: darwin
goarch: amd64
pkg: github.com/Q1mi/studygo/code_demo/test_demo/split
BenchmarkSplit-8                10000000               131 ns/op
BenchmarkSplitParallel-8        50000000                36.1 ns/op
PASS
ok      github.com/Q1mi/studygo/code_demo/test_demo/split       3.308s
```

还可以通过在测试命令后添加`-cpu`参数如`go test -bench=. -cpu 1`来指定使用的CPU数量。

### 7. Setup与TearDown

测试程序有时需要在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）

#### 1. TestMain

通过在`*_test.go`文件中定义`TestMain`函数来可以在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）操作。

如果测试文件包含函数:`func TestMain(m *testing.M)`那么生成的测试会先调用 TestMain(m)，然后再运行具体测试。`TestMain`运行在主`goroutine`中, 可以在调用 `m.Run`前后做任何设置（setup）和拆卸（teardown）。退出测试的时候应该使用`m.Run`的返回值作为参数调用`os.Exit`。

一个使用`TestMain`来设置Setup和TearDown的示例如下：

```go
func TestMain(m *testing.M) {
	fmt.Println("write setup code here...") // 测试之前的做一些设置
	// 如果 TestMain 使用了 flags，这里应该加上flag.Parse()
	retCode := m.Run()                         // 执行测试
	fmt.Println("write teardown code here...") // 测试之后做一些拆卸工作
	os.Exit(retCode)                           // 退出测试
}
```

需要注意的是：在调用`TestMain`时, `flag.Parse`并没有被调用。所以如果`TestMain` 依赖于command-line标志 (包括 testing 包的标记), 则应该显示的调用`flag.Parse`。

#### 2. 子测试的Setup与Teardown

有时候我们可能需要为每个测试集设置Setup与Teardown，也有可能需要为每个子测试设置Setup与Teardown。下面我们定义两个函数工具函数如下：

```go
// 测试集的Setup与Teardown
func setupTestCase(t *testing.T) func(t *testing.T) {
	t.Log("如有需要在此执行:测试之前的setup")
	return func(t *testing.T) {
		t.Log("如有需要在此执行:测试之后的teardown")
	}
}

// 子测试的Setup与Teardown
func setupSubTest(t *testing.T) func(t *testing.T) {
	t.Log("如有需要在此执行:子测试之前的setup")
	return func(t *testing.T) {
		t.Log("如有需要在此执行:子测试之后的teardown")
	}
}
```

使用方式如下：

```go
func TestSplit(t *testing.T) {
	type test struct { // 定义test结构体
		input string
		sep   string
		want  []string
	}
	tests := map[string]test{ // 测试用例使用map存储
		"simple":      {input: "a:b:c", sep: ":", want: []string{"a", "b", "c"}},
		"wrong sep":   {input: "a:b:c", sep: ",", want: []string{"a:b:c"}},
		"more sep":    {input: "abcd", sep: "bc", want: []string{"a", "d"}},
		"leading sep": {input: "沙河有沙又有河", sep: "沙", want: []string{"", "河有", "又有河"}},
	}
	teardownTestCase := setupTestCase(t) // 测试之前执行setup操作
	defer teardownTestCase(t)            // 测试之后执行testdoen操作

	for name, tc := range tests {
		t.Run(name, func(t *testing.T) { // 使用t.Run()执行子测试
			teardownSubTest := setupSubTest(t) // 子测试之前执行setup操作
			defer teardownSubTest(t)           // 测试之后执行testdoen操作
			got := Split(tc.input, tc.sep)
			if !reflect.DeepEqual(got, tc.want) {
				t.Errorf("excepted:%#v, got:%#v", tc.want, got)
			}
		})
	}
}
```

测试结果如下：

```bash
split $ go test -v
=== RUN   TestSplit
=== RUN   TestSplit/simple
=== RUN   TestSplit/wrong_sep
=== RUN   TestSplit/more_sep
=== RUN   TestSplit/leading_sep
--- PASS: TestSplit (0.00s)
    split_test.go:71: 如有需要在此执行:测试之前的setup
    --- PASS: TestSplit/simple (0.00s)
        split_test.go:79: 如有需要在此执行:子测试之前的setup
        split_test.go:81: 如有需要在此执行:子测试之后的teardown
    --- PASS: TestSplit/wrong_sep (0.00s)
        split_test.go:79: 如有需要在此执行:子测试之前的setup
        split_test.go:81: 如有需要在此执行:子测试之后的teardown
    --- PASS: TestSplit/more_sep (0.00s)
        split_test.go:79: 如有需要在此执行:子测试之前的setup
        split_test.go:81: 如有需要在此执行:子测试之后的teardown
    --- PASS: TestSplit/leading_sep (0.00s)
        split_test.go:79: 如有需要在此执行:子测试之前的setup
        split_test.go:81: 如有需要在此执行:子测试之后的teardown
    split_test.go:73: 如有需要在此执行:测试之后的teardown
=== RUN   ExampleSplit
--- PASS: ExampleSplit (0.00s)
PASS
ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s
```

### 8. 示例函数

#### 1. 示例函数的格式

被`go test`特殊对待的第三种函数就是示例函数，它们的函数名以`Example`为前缀。它们既没有参数也没有返回值。标准格式如下：

```go
func ExampleName() {
    // ...
}
```

#### 2. 示例函数示例

下面的代码是我们为`Split`函数编写的一个示例函数：

```go
func ExampleSplit() {
	fmt.Println(split.Split("a:b:c", ":"))
	fmt.Println(split.Split("沙河有沙又有河", "沙"))
	// Output:
	// [a b c]
	// [ 河有 又有河]
}
```

为你的代码编写示例代码有如下三个用处：

1. 示例函数能够作为文档直接使用，例如基于web的godoc中能把示例函数与对应的函数或包相关联。

2. 示例函数只要包含了`// Output:`也是可以通过`go test`运行的可执行测试。

   ```bash
   split $ go test -run Example
   PASS
   ok      github.com/Q1mi/studygo/code_demo/test_demo/split       0.006s
   ```

3. 示例函数提供了可以直接运行的示例代码，可以直接在`golang.org`的`godoc`文档服务器上使用`Go Playground`运行示例代码。下图为`strings.ToUpper`函数在Playground的示例函数效果。![Go Playground](https://www.liwenzhou.com/images/Go/unit_test/example.png)



----------------------

## 3.3 并发编程:

Go语言的并发通过`goroutine`实现。`goroutine`类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个`goroutine`并发工作。`goroutine`是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成。

Go语言还提供`channel`在多个`goroutine`间进行通信。`goroutine`和`channel`是 Go 语言秉承的 CSP（Communicating Sequential Process）并发模式的重要实现基础。

###　1. 线程,进程,协程: 

`进程`是操作系统进行资源分配的基本单位,进程可以创建销毁多个线程,一个程序至少有一个进程,一个进程至少有一个线程

`线程`是操作系统进行调度的基本单位,是程序执行的最小单位

`协程`是更轻量级的线程.

### 2. go协程和go主线程: 

**go主线程**: 一个go线程上,可以起多个协程

**go协程**: 协程是轻量级的线程[编译器做优化],有以下几个特点:

- 有独立的栈空间
- 共享程序堆空间
- 调度由用户控制,go的`runtime`调度和管理

### 3. 线程模型介绍:

通常在我们的操作系统中,线程被分为了两部分,用户线程和内核线程

**一对一模型:**java就是基于这种模型

一个用户线程对应一个内核线程.

![image-20210731204941148](03_go进阶语法.assets/image-20210731204941148.png)

优点: 多处理器硬件下,内核空间线程支持了真正意义上的并行,当某个用户线程被阻塞之后,内核线程通过上下文切换可以去执行其他的用户线程,并发度高

缺点: 每个用户线程都要创建一个内核线程与其对应,创建线程的开销很大,影响程序的性能

**多对一模型:**

多个用户线程对应一个内核线程,同时同一个用户线程只能对应一个内核线程,此时同一个内核线程上的用户线程的上下文切换是由用户态的运行时线程库来的,不由操作系统调度

![image-20210731205725963](03_go进阶语法.assets/image-20210731205725963.png)

优点: 线程上线文切换是由用户运行时线程库处理,开销很小速度快;线程的数量只受到内存大小的限制

缺点: 由于多个线程绑定在一个内核线程上,一旦该内核线程应为某个用户线程而阻塞,那么该内核线程上的其他线程无法执行.并发度不高.

**多对多模型:** go --- 详细的后面了解

结合上面两个模型, 让大量的用户线程对应在少数几个内核线程上,换句话说: 一个用户线程可以选择性的在某个内核线程上执行.

![image-20210731210011100](03_go进阶语法.assets/image-20210731210011100.png)

优点: 多个线程被绑定在了多个内核线程上,上线文切换发生在用户空间, 当某个用户线程阻塞从而阻塞内核线程的时候,该内核线程的其他用户线程可以由运行时线程库调度到其他内核线程上去执行

### 4. GMP模型:

[GMP模型](https://www.ituring.com.cn/book/tupubarticle/16048)

G(`goroutine`):一个G代表一个Go代码片段。前者是对后者的一种封装。里面除了存放本`goroutine`信息外 还有与所在P的绑定等信息。

M(`machine`):一个M代表一个内核线程，或者“工作线程”。在大多数情况下，创建一个新M的原因是没有足够的M来关联P并运行其中可运行的G。不过，在运行时系统执行系统监控或垃圾回收等任务的时候，也会导致新M的创建。M的部分结

P(`processor`): 一个P代表执行一个Go代码片段所必需的资源（或称“上下文环境”）。管理着一组`goroutine`队列，P里面会存储当前`goroutine`运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的`goroutine`队列做一些调度（比如把占用CPU时间较长的`goroutine`暂停、运行后续的`goroutine`等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。

简单来说，一个G的执行需要P和M的支持。一个M在与一个P关联之后，就形成了一个有效的G运行环境（内核线程+上下文环境）。每个P都会包含一个可运行的G的队列（`runq`）。该队列中的G会被依次传递给与本地P关联的M，并获得运行时机。

`GMP`与内核调度实体`KSE`之间的关系:

![image-20210731225610667](03_go进阶语法.assets/image-20210731225610667.png)

可以看到，M与`KSE`之间总是一对一的关系，一个M能且仅能代表一个内核线程。Go的运行时系统（runtime system）用M代表一个内核调度实体。M与`KSE`之间的关联非常稳固，一个M在其生命周期内，会且仅会与一个`KSE`产生关联。相比之下，M与P、P与G之间的关联都是易变的，它们之间的关系会在实际调度的过程中改变。此外，M与G之间也会建立关联，因为一个G终归会由一个M来负责运行；它们之间的关联会由P来牵线。注意，由于M、P和G之间的关系在实际调度过程中多变，图2-2中的可能关联仅能作为一般性的示意。

单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，`goroutine`则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为`m:n`调度的技术（复用/调度m个`goroutine`到n个OS线程）。 其一大特点是`goroutine`的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的`malloc`函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干`goroutine`均分在物理线程上， 再加上本身`goroutine`的超轻量，以上种种保证了go调度方面的性能。

### 5. 开启`goroutine`:

go将一个函数直接当作一个任务,通过关键字`go`直接提交给goroutine去执行

```go
// 这就表示开启了一个任务了
go funcName()
```



```go
func goroutineTest(){
	// 把一个函数当做是一个任务,然后调用的时候加上go关键字,就开启另外一个goroutine了
	go task()
	for i := 0; i < 10 ; i++ {
		fmt.Println("测试goroutine!!!!!!  main")
		time.Sleep(time.Second)
	}
}
func task(){
	for i := 0; i < 10 ; i++ {
		fmt.Println("测试goroutine!!!!!! task")
		time.Sleep(time.Second)
	}
}
```



go语言可以设置程序在运行的时候,程序所使用的`cpu`核心数,默认是当前环境`cpu`最大核心数.

Go运行时的调度器使用`GOMAXPROCS`参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（`GOMAXPROCS`是`m:n`调度中的n）。

`Go1.5`版本之前，默认使用的是单核心执行。`Go1.5`版本之后，默认使用全部的CPU逻辑核心数。

```go
func setCPUSize(){
	// 获取当前系统cpu数量
	cpu := runtime.NumCPU()
	fmt.Println("cur cpu size = ",cpu)

	// 将go程序所用cpu数量设置为1
	runtime.GOMAXPROCS(1)
}
```

### 6. channel:

go为了避免发生竞态问题,避免保证数据正确交换从而必须加锁的问题,就没有采用 `共享内存通信`,而是采用`CSP`模型通过`通信来共享内存`.

如果说`goroutine`是Go程序并发的执行体，`channel`就是它们之间的连接。`channel`是可以让一个`goroutine`发送特定值到另一个`goroutine`的通信机制。

#### 1. 什么是channel

1. Go 语言中的通道（channel）是一种特殊的类型。
2. `channel`本质上就是存放`多个相同类型元素`的队列,元素总是遵循`先进先出`的规则进出`channel`
3. `channel`本身就是线程安全的,多个`goroutine`访问`channel`无需加锁也不会发生线程安全问题

#### 2. 声明channel

```go
var 变量 chan 数据类型
// 必须初始化之后才能使用
变量 := make(chan 数据类型, [缓冲大小])
```

说明:

1. `channel`是引用类型
2. `channel`必须要初始化后才能写入数据,
3. `channel`是由类型限制的,如同`ArrayList<Integer>`只能 存放Integer元素

#### 3. 操作channel:

通道有 `发送到ch(send)`,`从ch接收(recive)`,`关闭ch(close)`三个操作,其中发送接收都是 `<-`,指向`channel`表示写入channel,背离`chanel`表示接收

发送:

```go
ch <- 10 // 向channel中写入 10
```

接受

```go
x := <- ch // 从channel接收
<- ch // 从ch接收但是忽略掉
```

关闭

```go
close(ch)
```

关于关闭通道需要注意的事情是，只有在通知接收方`goroutine所有的数据都发送完毕`的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。

对一个已经关闭的通道进行不同操作,可能产生以下情况:

1. 对关闭的channel继续发送会导致`panic`
2. 对关闭的channel继续接收会直接获取值到通道为空
3. 对关闭的channel且已经没有值得通道执行接收操作会的到对应类型的零值
4. 对关闭的通道执行关闭操作会造成`panic`
5. 如果没有使用`goroutine`的情况下,channel中的数据取完了,再取会造成死锁
6. 如果`channel`是无缓冲的 `make(chan int)`这种,在没有接收方的时候写入数据也会造成死锁

遍历: for-range

<font color=red>for-range在遍历 channel,遍历完所有的元素之后,如果channel没有关闭,还会去channel中获取一次.,但是也只是获取一次,获取完之后,在协程中会一直阻塞在那里,主线程中会直接报 `死锁` </font>

```go
func main() {
	ch1 := make(chan int, 100)
	// 写入
	for i := 0; i < 100; i++ {
		ch1 <- i*2
	}

	go func() {
		count := 0
		// 遍历取出
		for v := range ch1 {
			count++
			fmt.Printf("第 %d 次遍历,v = %d\n",count,v)
			if count == 100 {
				// 如果count == 100,ch1里面去写一个数
				go func() {
					ch1 <- 1
				}()
			}
			fmt.Println(" --- ")
		}
		fmt.Println("拿完了")
	}()
    ch1 <- 10086
	time.Sleep(10 * time.Second)
}
```

说明: 为了证明for在获取完chan里面数据后,还会去获取chan中的元素,遍历ch1的每一轮最后都会输出 ---,在第一百次也就是最后一次,又开启一个协程去给ch1添加了一个元素

![image-20210801010451123](03_go进阶语法.assets/image-20210801010451123.png)

**无缓冲的通道**

无缓冲的通道又称为阻塞通道,下面的代码会造成死锁,因为没有接收方,代码会一直阻塞在 `ch <- 10`

```go
func main() {
	ch := make(chan int)
	ch <- 10
	fmt.Println("发送成功")
}
```

```go
// 解决无缓冲通道写入造成死锁
func recv(c chan int) {
	ret := <-c
	fmt.Println("接收成功", ret)
}
func main() {
	ch := make(chan int)
	go recv(ch) // 启用goroutine从通道接收值
	ch <- 10
	fmt.Println("发送成功")
}
```

无缓冲通道上的发送操作会阻塞，直到另一个`goroutine`在该通道上执行接收操作，这时值才能发送成功，两个`goroutine`将继续执行。相反，如果接收操作先执行，接收方的`goroutine`将阻塞，直到另一个`goroutine`在该通道上发送一个值。

使用无缓冲通道进行通信将导致发送和接收的`goroutine`同步化。因此，无缓冲通道也被称为`同步通道`。

**单向通道:**

通道可以在声明的时候指定其为只读或只写通道

```go
var 变量 chan<- int // 声明一个只写通道
var 变量 <-chan int // 声明一个只读通道
```

<font color=red>在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。</font>

#### 4. 总结:

![image-20210801011440834](03_go进阶语法.assets/image-20210801011440834.png)
